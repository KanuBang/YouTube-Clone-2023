1. try-catch문으로 에러처리
에러가 발생하면 try에서 코드를 멈추고 catch로 넘어간다.
에러가 없다면 catch는 암것도 안 함.

2. 데이터 형태를 저장할때 Date.now가 아닌 Date.now()를 한 이유는

데이터 형태를 저장할 때
Date.now()를 한다면 데이터 형태를 저장할 때 그때 시간이 저장된다.
그렇기에 데이터 형태를 저장할 때는 Date.now를 한다.

즉, 이렇게 하는 이유는 몽구스에게 내가 새로운 비디오를 생성했을때 그 시간을 저장하겠다고 알리는 것이다

3. 구체적인 데이터 형태들
1) required: true or false => 필수 입력 여부 => 왜 쓸까?
a라는 데이터의 형태를 required를 설정하지 않고 저장한다면
a의 값을 저장할때 a를 빼먹어도 에러가 발생하지 않는다.

이런 것을 바지하기 위해 required를 쓴다.

2) default: value는 왜 쓸까?

예를 들어서 한국 비디오에는 다 노란색깔 배경을 입힌다고 해보자.
데이터를 실제로 저장할때 color: yellow를 하는 것 보다
아예 데이터 형태를 저장할 때 color : {default: yellow} 하는 것이
code management 효율성 그리고 코드 양을 줄이는 측면에서 효율적이다.

3) error._message는 왜 쓸까?
try-catch 문에서 에러가 발생했을때 
에러의 메시지는 error._message로부터 알 수 있다.
error는 catch문에서 받는 변수다.
이름만 error이기에 다른 이름으로 바뀔 수 있다.

______________________________________________________________________________________
1. trim: true or false 는 왜 쓸까>

trim은 문자열의 양옆 공백을 짜르는 역할을 한다.

2. minLength, maxLength 는 html에 쓸까? 백엔드에 쓸까?

둘 다 쓰자. 각자의 목적이 있다.

html에서의 글자 제한은 유저와의 원활한 소통을 위해서이다.
만약 백엔드에서 글자 제한을 뒀는데 유저가 이 사실을 모른다면 
왜 에러가 발생하는지 이해를 못 할 것이다.
그래서 html에 글자 제한이 필요하다.

백엔드에 글자 제한을 쓰는 것은 db의 데이터 형태를 저장하기 위함이다.

3. 우리가 데이터를 저장하면 몽구스는 데이터 별로 id를 부여한다.

4. uppercase: true는 내가 소문자로 적어도 몽구스가 대문자로 바꿔준다.

______________________________________________________________________________________

1. 몽구스가 각 데이터에 부여하는 id는
24바이트 16진수이다.

2. findById는 id로 데이터를 찾는 거다.

3. findById를 이용해서 id로 데이터를 찾기 위해서는 url에 16진수 정규식이 필요하다.

4. [0-9a-f]{24}
0부터9 그리고 a부터 f까지의 24자 string을 찾아내자