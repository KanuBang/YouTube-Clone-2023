abc
gdrffg@gmail.com
chan
qwer1234
seoul

1.$or => 배열에서 or 연산을 실행한다.

The $or operator performs a logical OR operation 
on an array of one or more <expressions> and selects the documents 
that satisfy at least one of the <expressions>. 
The $or has the following syntax:
{ $or: [ { <expression1> }, { <expression2> }, ... , { <expressionN> } ] }

2. 작업 내용
패스워드 확인, 이메일 or 유저네임 존재 여부를 몽고 DB에서 체크한다.
만약 패스워드 확인이 일치하지 않거나 이메일 or 유저네임이 존재하는 에러와 같은 것은
if로 처리했고 에러 발생시 에럼 메지와 함께 return으로 컨트롤러를 종료시켰다.

즉,
1. if문으로 먼저 에러 처리
2. 에러 발생시 에러 설명과 함께 return 하여 함수를 종료
3. if문에 안 걸린 코드는 문제 없는 코드

______________________________________________________________________________________

1. 응답할때 상태코드를 써여 하는 이유
응답할때 상태코드를 써야만 브라우저가 적절한 반응을 할 수 있다.
브라우저가 적절한 반응을 해야만 유저가 편해질 것이다.

예를 들어,
우리가 로그인 할때 브라우저는 자동으로 아이디, pwd를 저장할까요? 라는 반응을 보여준다.
근데 만약 비밀번호 잘못 입력했을때도 브라우저가 이러한 반응을 보이면 유저 입장에서는 난처하다.
그래서 상태코드 400 추가로 보내 뭔가 에러가 발생했음을 브라우저에게 알리고
브라우저가 자동으로 하는 동작(id, pwd 저장)을 유저에게 하지 못하게 한다.

상태코드 4백대는 실패
상캐코드 3백대는 성공을 의미한다.

______________________________________________________________________________________

1. 작업 내용

1) 로그인을 만들었다.

먼저 로그인 라우터에 get, post를 처리하는 컨트롤러를 만들었고
getLogin 컨트롤러는 login.pug를 단순히 렌더링한ㄴ 역할이다.
postLogin 컨트롤러는 유저네임과 패스워드를 받아서 실제로 로그인 하는 역할이다.
(물론, 지금 상태에서는 아직 다 구현하지 못 했다.)

2) login.pug / join.pug
계정이 있다면 로그인 창으로 넘어 갈 수 있도록
계정이 없다면 가입 창으로 넘어 갈 수 있도록 
pug 파일에 a 태그를 넣었다.

______________________________________________________________________________________

1.  Model.findOne(검색조건) vs  Model.findById(id)
검색조건과 일치하는 객체를 리턴한다.
vs
id와 일치하는 객체를 리턴한다.

2. 작업 내용
id가 존재하는지 안 하는지 체크했고
유저가 입력한 pwd와 db에 있는 pwd가 일치하는지 해쉬로 비교했다.

각각의 if문은 id가 존재하지 않을때 비밀번호가 일치않을때 처리하는 제어문이고
이때는 명배한 에러이기에 return으로 함수를 종료시키고 브라우저에게 상태코드와 함께 응답한다.

if문 다음 맨 마지막 코드는 정상인 코드, 즉, 로그인에 성공했을 때 코드이다.

______________________________________________________________________________________

1.  const ok = await bcrypt.compare(password, user.password)

bcrypt.compare(비교해볼 문자열, 해시값, 콜백메소드)

password = 유저가 입력한 비교해 볼 문자열
user.password = DB에 저장된 pwd 해시값

______________________________________________________________________________________

1. 로그인 인증 시스템 = 세션, 세션 id, 쿠키

쿠키와 세션ID 덕분에 로그인을 하지 않아도 서버가 어떤 브라우저가 어떤 브라우저인지 알 수 있다.
브라우저가 처음 백엔드에게 요청을 보내고 백엔드가 응답할때 
백엔드는 각 브라우저에게 "아 너구나!"라고 할 만한 세션 ID를 함께 응답으로 보낸다.
그리고 각 브라우저는 그 세션 ID를 쿠키에 보관한다.

각 브라우저는 다시 그 백엔드에게 요청을 보낼때 쿠키(세션 ID를 포함한)와 함께 요청을 보낸다.
백엔드는 요청과 함께 온 쿠키(세션 ID를 포함한)덕분에 "아 너가 개 였지!"라고 하며 각 브라우저를 기억할 수 있다.

좀 더 정확하게 말하자면 브라우저가 보낸 쿠키에 있는 세션 ID와 세션 DB에 있는 세션 ID를 비교하여
"너가 개구나!" 한다.
 
어쨋든 로그인 하지 않더라도 백엔드는 한 번 방문한 브라우저를 구별 할 수 있다.

2. 세션으로 브라우저와 있었던 일(정보)와 브라우저를 식별한다.
세션은 브라우저와 백엔드 간의 히스토리 or 메모리다.
백엔드와 각 브라우저간의 있었던 일이 이 히스토리와 메모리에 저장된다.

대표적으로 세션에 있는 세션 아이디 덕분에 백엔드가 각 브라우저를 식별할 수 있다.

3. stateless?
와이파이를 생각해보자. 와이파이에 pin 번호를 한 번 입력하면 와이파이와 폰은 계속해서 연결되어 있다.
하지만, 백엔드와 브라우저는 그렇지 않다. 세션 id를 통해서 지속적으로 연결을 확인해야 한다.

3. 작업 설명
세션 미들웨어 => 이 미들웨어가 이 사이트로 들어오는 유저를 기억할 것
세션 미들웨어 => express가 알아서 그 브라우저를 위한 세션 id를 만든다

오페라,엣지,크롬 브라우저를 통해서 
백엔드가 각 브라우저를 식별하고 그 브라우저에 대한 정보를
세션DB에 담는 과정을 학인함.

______________________________________________________________________________________

1. local 오브젝트

pug랑 express가 서로 locals를 공유할 수 있다.
그래서 locals는 이미 모든 pug template에 import된 object다.
그래서 모든 pug에서 같은 locals를 읽을 수 있다
즉, locals는 전역이다.

2. locals 오브젝트 사용법
locals로 변수를 담으면 모든 pug 탬플릿이 그 변수를 접근하고 사용할 수 있다.

그래서 그 locals에 로그인한 사용자를 추가하여
각 pug 템플릿들이 누가 로그인 했는지 알도록 한다.
즉, 누가 로그인 했는지 공유 한다는 말이다.

3. 로컬 미들웨어가 세션 미들웨어 다음으로 와야한다
결국 로그인 시스템에서 로컬 미들웨어는 사용자 정보, 즉, 세션 정보를 다루기에
세션 미들웨어 다음으로 와야한다.

4. 내가 코드를 저장할때마다 session은 사라진다
아직 DB에 세션을 저장하지 않았기 때문에 각 브라우저에 대한 세션 정보는 재시작할때마다 달라진다.

5. 작업 정리

1) userController의 postLogin 컨트롤러에서 어떤 유저가 로그인에 성공했다면 
세션의 loggedIn과 user 정보를 추가한다.

2) 로컬 미들웨어를 만들어 locals 객체에다가 세션 data를 담는다.

3) 그리고 그 locals 객체를 pug 템플릿인 base에다가 사용하였다.


즉, 
1) 세션 미들웨어가 세션을 생성하고
2) 어떤 한 유저가 로그인이 성공하면
세션에 로그인 성공 여부, 유저 네임을 담고
3) 그 세션 정보를 다시 locals 객체에 전달하여
4) pug파일에서도 locals를 이용하여 session 정보를 사용하도록 하였다.


